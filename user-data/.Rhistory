saveWorkbook(wb, file)
}
options(java.parameters = "-Xmx8000m")
library(rJava)
library(xlsx)
#install.packages("xlsx")
#install.packages("rJava")
#Add jvm.dll to your PATH, w/ 64 bit java
options(java.parameters = "-Xmx8000m")
library(rJava)
library(xlsx)
path <- "S:/Projects/Programme resources/Data/GHA calcs and analyses/April 2015/Datasets - do not edit/CRS/Raw/"
wd <- "S:/Projects/Programme resources/Data/GHA calcs and analyses/April 2015/Datasets - do not edit/CRS/"
#List all files in country-year
filenames <- list.files(path, pattern="*-enc.txt", full.names=TRUE)
#Iterate through files, reading them in
for (i in 1:length(filenames))
{
basename = substr(basename(filenames[i]), 1, nchar(basename(filenames[i])) - 4)
dat <- read.table(
filenames[i]
,header = TRUE
,sep = "|"
,fileEncoding="latin1"
,na.strings=NULL
,quote=""
,as.is=T
,fill=TRUE
)
#Write xlsx
file <- paste0(basename,".xlsx")
wb <- createWorkbook()
sheet <- createSheet(wb,sheetName="crs data")
addDataFrame(dat,sheet,row.names=FALSE)
saveWorkbook(wb, file)
}
getwd()
###Function########################################################################################
###Thanks to Kyle Walker, http://rpubs.com/walkerke/wdi_leaflet
#install.packages('rgdal')
#install.packages('devtools')
#install.packages('plyr')
#library(devtools)
#devtools::install_github("rstudio/leaflet")
library(rgdal)
library(leaflet)
library(plyr)
### Function to create a Leaflet interactive map.
diRamp <- function(colorText1,colorText2=NA,colorText3=NA){
colorRef <- list("red"="#BA0C2F")
colorRef <- c(colorRef,"white"="#FFFFFF")
colorRef <- c(colorRef,"black"="#000000")
colorRef <- c(colorRef,"orange"="#EA7600")
colorRef <- c(colorRef,"purple"="#93328E")
colorRef <- c(colorRef,"blue"="#1B365D")
colorRef <- c(colorRef,"lightblue"="#0095CB")
colorRef <- c(colorRef,"yellow"="#B7BF10")
colorRef <- c(colorRef,"darkred"=rgb(96, 6, 24,1,maxColorValue=255))
colorRef <- c(colorRef,"pink"=rgb(251, 197, 208,1,maxColorValue=255))
colorRef <- c(colorRef,"blue4"=rgb(27, 54, 93,1,maxColorValue=255))
colorRef <- c(colorRef,"blue3"=rgb(73, 94, 125,1,maxColorValue=255))
colorRef <- c(colorRef,"blue2"=rgb(118, 134, 158,1,maxColorValue=255))
colorRef <- c(colorRef,"blue1"=rgb(164, 175, 190,1,maxColorValue=255))
colorRef <- c(colorRef,"blue0"=rgb(209, 215, 223,1,maxColorValue=255))
if(!is.na(colorText2)){
if(!is.na(colorText3)){
color1 <- colorRef[[colorText1]]
if(is.null(color1)){color1 <- colorText1}
color2 <- colorRef[[colorText2]]
if(is.null(color2)){color2 <- colorText2}
color3 <- colorRef[[colorText3]]
if(is.null(color3)){color3 <- colorText3}
colorRamp(c(color1,color2,color3), interpolate="linear")
}else{
color1 <- colorRef[[colorText1]]
if(is.null(color1)){color1 <- colorText1}
color2 <- colorRef[[colorText2]]
if(is.null(color2)){color2 <- colorText2}
colorRamp(c(color1,color2), interpolate="linear")
}
}else{
color1 <- colorRef[["white"]]
color2 <- colorRef[[colorText1]]
if(is.null(color2)){color2 <- colorText2}
colorRamp(c(color1,color2), interpolate="linear")
}
}
hub_leaflet <- function(series,indicator, year = NA, value = "value", classes = 5, colors = "Blues") {
url <- "http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/cultural/ne_50m_admin_0_countries.zip"
tmp <- tempdir()
file <- basename(url)
if(!file.exists(file)){
download.file(url, file)
}
unzip(file, exdir = tmp)
countries <- readOGR(dsn = tmp,
layer = "ne_50m_admin_0_countries",
encoding = "UTF-8",
verbose = FALSE)
datPath <- paste("C:/git/digital-platform/",series,"/",indicator,".csv",sep="")
dat <- read.csv(datPath, header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE,row.names=NULL)
if(!is.na(year)){
dat <- dat[which(dat$year==year),]
}
keep <- c("iso2c","year",indicator)
names(dat)[names(dat) == "id"] <- "iso2c"
names(dat)[names(dat) == value] <- indicator
dat <- dat[keep]
countries2 <- merge(countries,
dat,
by.x = "iso_a2",
by.y = "iso2c",
sort = FALSE)
countries2$country <- countries2$name
if(is.numeric(classes)){
if(length(classes)==1){
pal <- colorQuantile(colors, NULL, n = classes)
}else{
levels <- classes[order(classes)]
indDat <- dat[[indicator]]
indDat <- indDat[which(!is.na(indDat))]
indMin <- min(indDat)
indMax <- max(indDat)
if(levels[1]>indMin){
levels <- c(indMin,levels)
}
if(levels[length(levels)]<indMax){
levels <- c(levels,indMax)
}
pal <- colorBin(colors, c(indMin,indMax) , bins = levels)
}
}else{
conceptPath <- "C:/git/digital-platform/concepts.csv"
concepts <- read.csv(conceptPath, header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
range <- concepts[which(concepts$id==indicator&concepts$series=="country-year"),]$range
if(!is.na(range)){
classes <- as.numeric(strsplit(range,",")[[1]])
levels <- classes[order(classes)]
indDat <- dat[[indicator]]
indDat <- indDat[which(!is.na(indDat))]
indMin <- min(indDat)
indMax <- max(indDat)
if(levels[1]>indMin){
levels <- c(indMin,levels)
}
if(levels[length(levels)]<indMax){
levels <- c(levels,indMax)
}
pal <- colorBin(colors, c(indMin,indMax) , bins = levels)
}else{
warning("Error reading range from concepts.csv. Choosing 5 chucks instead.")
pal <- colorQuantile(colors, NULL, n = 5)
}
}
country_popup <- paste0("<strong>Country: </strong>",
countries2$country,
"<br><strong>",
indicator,
", ",
as.character(countries2$year),
": </strong>",
countries2[[indicator]])
stamen_tiles <- "http://{s}.tile.stamen.com/toner-lite/{z}/{x}/{y}.png"
stamen_attribution <- 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.'
val<-countries2[[indicator]]
color<- pal(countries2[[indicator]])
legend <- data.frame(val,color,stringsAsFactors=FALSE)
legend <- ddply(legend,.(color),summarize,from=min(val),to=max(val),count=length(val),stringsAsFactors=FALSE)
legend <- legend[order(legend$from),]
legend$from.to <- paste(as.character(legend$from),as.character(legend$to),sep=" - ")
legend<- legend[c("color","from.to","count")]
for(i in 1:length(legend$from.to)){
if(legend$from.to[i]=="NA - NA"){
legend$from.to[i]="NA"
}
}
bp <- barplot(legend$count,
legend.text=legend$from.to,
beside=FALSE,
col=legend$color,
main = indicator)
text(bp, 0, round(legend$count, 1),cex=1,pos=3)
leaflet(data = countries2) %>%
#addTiles(urlTemplate = stamen_tiles,
#         attribution = stamen_attribution) %>%
setView(0, 0, zoom = 2) %>%
addPolygons(fillColor = ~pal(countries2[[indicator]]),
fillOpacity = 0.8,
color = "#BDBDC3",
weight = 1,
popup = country_popup)
}
##Syntax is:
#hub_leaflet(series,indicator,year,value,classes,colorRamp)
#Map appears in viewer, legend appears in plots along with count of data in those bins
####Files that appear in Global Picture
hub_leaflet("latest-year","oda-to-ldcs-pc-gni",NA,"value",c(0.02, 0.04, 0.08, 0.16),diRamp("purple"))
hub_leaflet("latest-year","oda-to-ldcs-pc-gni",NA,"value",c(0.02, 0.04, 0.08, 0.15, 0.2),diRamp("purple"))
path<- "C:/git/digital-platform"
setwd(path)
df <- read.csv("./country-year/domestic.csv", header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
mult <- read.csv("./reference/current-ncu-to-constant-2012-usd-cy.csv", header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
if("value-ncu" %in% colnames(df)){
names(df)[names(df)=="value-ncu"] <- "value.ncu"
df$value <- df["value-ncu"]
}else{
df$value.ncu <- df$value
}
for(i in 1:nrow(df)){
row = df[i,]
id = row[1][1,1]
year = row[2][1,1]
value = row[11][1,1]
multiplier = mult[which(mult$id==id),]
multiplier = multiplier[which(multiplier$year==year),3]
if(length(multiplier)<=0)
{
if(year!=2020){print(paste("No multiplier for:",id,year))}
df[i,11] = NA
}
else
{
value = value*multiplier
df[i,11] = value
}
}
path<- "C:/git/digital-platform"
setwd(path)
df <- read.csv("./country-year/domestic.csv", header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
mult <- read.csv("./reference/current-ncu-to-constant-2012-usd-cy.csv", header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
if("value-ncu" %in% colnames(df)){
names(df)[names(df)=="value-ncu"] <- "value.ncu"
df$value <- df$value.ncu
}else{
df$value.ncu <- df$value
}
for(i in 1:nrow(df)){
row = df[i,]
id = row[1][1,1]
year = row[2][1,1]
value = row[11][1,1]
multiplier = mult[which(mult$id==id),]
multiplier = multiplier[which(multiplier$year==year),3]
if(length(multiplier)<=0)
{
if(year!=2020){print(paste("No multiplier for:",id,year))}
df[i,11] = NA
}
else
{
value = value*multiplier
df[i,11] = value
}
}
names(df)[names(df) == "value.ncu"] <- "value-ncu"
write.csv(df,"./country-year/domestic.csv",row.names=FALSE,na="")
path<- "C:/git/digital-platform/country-year/"
setwd(path)
df <- read.csv("./domestic.csv", header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
gdp <- read.csv("./gdp-current-ncu-fy.csv", header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
id <- c()
year <- c()
value <- c()
estimate <- c()
for(i in 1:nrow(df)){
row <- df[i,]
dfid <- row[1][1,1]
dfyear <- row[2][1,1]
l1 <- row[5][1,1]
l2 <- row[6][1,1]
l3 <- row[7][1,1]
dfvalue <- row[11][1,1]
if(!is.na(l1) && !is.na(l2)){
if(l1=="total-revenue-and-grants" && l2=="revenue" && is.na(l3)){
id <- c(id,dfid)
year <- c(year,dfyear)
thisGDP <- gdp[which(gdp$id==dfid),]
thisGDP <- thisGDP[which(thisGDP$year==dfyear),]
if(nrow(thisGDP)>0){
if(is.na(thisGDP$value[[1]])){
value <- c(value,NA)
estimate <- c(estimate,NA)
}else{
value <- c(value,dfvalue/thisGDP$value[[1]])
estimate <- c(estimate,thisGDP$estimate[[1]])
}
}else{
value <- c(value,NA)
estimate <- c(estimate,NA)
print(paste("No multiplier for:",dfid,dfyear))
}
}
}
}
newdf <- data.frame(id,year,value,estimate)
write.csv(newdf,"./gov-revenue-pc-gdp.csv",row.names=FALSE,na="")
#install.packages('reshape')
#install.packages("utils")
library(reshape)
library(utils)
wd <- "C:/git/digital-platform/user-data/"
setwd(wd)
#Delete everything in user-data
unlink(dir(wd, full.names = TRUE),recursive=TRUE)
#List all files in country-year
filenames <- list.files("C:/git/digital-platform/country-year/", pattern="*.csv", full.names=TRUE)
#Define references and mapping
refPath = "C:/git/digital-platform/reference/"
conceptPath = "C:/git/digital-platform/concepts.csv"
concepts <- read.csv(conceptPath, header = TRUE,sep=",",na.strings="",check.names=FALSE)
refMap <- list("domestic"="budget-type,domestic-budget-level")
refMap <- c(refMap,"domestic-sectors"="budget-type,domestic-budget-level")
refMap <- c(refMap,"domestic-netlending"="budget-type,domestic-budget-level")
refMap <- c(refMap,"intl-flows-donors"="flow-type,flow-name")
refMap <- c(refMap,"intl-flows-recipients"="flow-type,flow-name")
refMap <- c(refMap,"largest-intl-flow"="largest-intl-flow")
refMap <- c(refMap,"fragile-states"="fragile-states")
refMap <- c(refMap,"long-term-debt"="debt-flow,destination-institution-type,creditor-type,creditor-institution,financing-type")
refMap <- c(refMap,"oda"="sector,bundle,channel")
refMap <- c(refMap,"oof"="sector,oof-bundle,channel")
refMap <- c(refMap,"fdi-out"="financing-type")
refMap <- c(refMap,"dfis-out-dev"="financing-type")
refMap <- c(refMap,"ssc-out"="financing-type")
#Iterate through files, reading them in
for (i in 1:length(filenames))
{
data <- read.csv(filenames[i], header = TRUE,sep=",",na.strings="",check.names=FALSE)
names <- colnames(data)
basename = substr(basename(filenames[i]), 1, nchar(basename(filenames[i])) - 4)
fwd = paste(wd,basename,sep="/")
#Create a folder for each csv
dir.create(fwd)
setwd(fwd)
concept = concepts[which(concepts$id==basename),]
#If we have an ID and a year to widen it by, provide wide
if("id" %in% names & "year" %in% names)  {
wdata <- reshape(data,idvar="id",timevar="year",direction="wide")
write.csv(wdata,paste(basename,"-wide",".csv",sep=""),row.names=FALSE,na="")
}
#Copy the original CSV
file.copy(filenames[i],paste(basename,".csv",sep=""))
#Reference folder
rwd = paste(fwd,"reference",sep="/")
dir.create(rwd)
setwd(rwd)
#Provide meta-data from concepts.csv
#write.csv(concept,paste(basename,"-metadata-wide",".csv",sep=""),row.names=FALSE,na="")
write.table(t(concept),paste(basename,"-metadata",".csv",sep=""),col.names=FALSE,na="",sep=",")
if(basename %in% names(refMap)){
refNames = strsplit(refMap[[basename]],",")
for(j in 1:length(refNames)){
refBaseName = refNames[[j]]
refName = paste(refPath,refBaseName,".csv",sep="")
#Copy the reference files
file.copy(refName,paste(refBaseName,".csv",sep=""))
}
}
setwd(wd)
}
#Zip em up
filenames <- list.files(wd, pattern="/*", full.names=FALSE)
for(i in 1:length(filenames)){
files <- dir(filenames[i],full.names=TRUE)
zip(zipfile = filenames[i],files=files)
}
path<- "C:/git/digital-platform"
setwd(path)
df <- read.csv("./country-year/domestic-netlending.csv", header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
mult <- read.csv("./reference/current-ncu-to-constant-2012-usd-cy.csv", header = TRUE,sep=",",na.strings="",check.names=FALSE,stringsAsFactors=FALSE)
if("value-ncu" %in% colnames(df)){
names(df)[names(df)=="value-ncu"] <- "value.ncu"
df$value <- df$value.ncu
}else{
df$value.ncu <- df$value
}
for(i in 1:nrow(df)){
row = df[i,]
id = row[1][1,1]
year = row[2][1,1]
value = row[11][1,1]
multiplier = mult[which(mult$id==id),]
multiplier = multiplier[which(multiplier$year==year),3]
if(length(multiplier)<=0)
{
if(year!=2020){print(paste("No multiplier for:",id,year))}
df[i,11] = NA
}
else
{
value = value*multiplier
df[i,11] = value
}
}
names(df)[names(df) == "value.ncu"] <- "value-ncu"
write.csv(df,"./country-year/domestic-netlending.csv",row.names=FALSE,na="")
#install.packages('plyr')
require(plyr)
setwd("C:/git/digital-platform/latest-year")
filenames <- list.files("C:/git/digital-platform/country-year", pattern="*.csv", full.names=TRUE)
latestYear <- function(data)
{
return(
ddply(data,.(id),function(x)
{
naLen <- nrow(x[which(is.na(x$value)),])
allLen <- nrow(x)
valueLen <- allLen-naLen
if(valueLen>=1)
{
for(i in 1:length(x$value))
{
if(!is.na(x$value[i])){
latestId = x$id[i]
latestYear = x$year[i]
latestVal = x$value[i]
}
}
}
else
{
latestId = x$id[1]
latestYear = max(x$year)
latestVal = NA
}
y <- c(latestYear,latestVal)
return(y)
}
)
)
}
for (i in 1:length(filenames))
{
data <- read.csv(filenames[i], header = TRUE,sep=",",na.strings="",check.names=FALSE)
names <- colnames(data)
if("id" %in% names & "year" %in% names & "value" %in% names)
{
data <- data[order(data$id,data$year),]
data <- latestYear(data)
names(data)[names(data) == "V1"] <- "year"
names(data)[names(data) == "V2"] <- "value"
write.csv(data,basename(filenames[i]),row.names=FALSE,na="")
}
}
#install.packages('reshape')
#install.packages("utils")
library(reshape)
library(utils)
wd <- "C:/git/digital-platform/user-data/"
setwd(wd)
#Delete everything in user-data
unlink(dir(wd, full.names = TRUE),recursive=TRUE)
#List all files in country-year
filenames <- list.files("C:/git/digital-platform/country-year/", pattern="*.csv", full.names=TRUE)
#Define references and mapping
refPath = "C:/git/digital-platform/reference/"
conceptPath = "C:/git/digital-platform/concepts.csv"
concepts <- read.csv(conceptPath, header = TRUE,sep=",",na.strings="",check.names=FALSE)
refMap <- list("domestic"="budget-type,domestic-budget-level")
refMap <- c(refMap,"domestic-sectors"="budget-type,domestic-budget-level")
refMap <- c(refMap,"domestic-netlending"="budget-type,domestic-budget-level")
refMap <- c(refMap,"intl-flows-donors"="flow-type,flow-name")
refMap <- c(refMap,"intl-flows-recipients"="flow-type,flow-name")
refMap <- c(refMap,"largest-intl-flow"="largest-intl-flow")
refMap <- c(refMap,"fragile-states"="fragile-states")
refMap <- c(refMap,"long-term-debt"="debt-flow,destination-institution-type,creditor-type,creditor-institution,financing-type")
refMap <- c(refMap,"oda"="sector,bundle,channel")
refMap <- c(refMap,"oof"="sector,oof-bundle,channel")
refMap <- c(refMap,"fdi-out"="financing-type")
refMap <- c(refMap,"dfis-out-dev"="financing-type")
refMap <- c(refMap,"ssc-out"="financing-type")
#Iterate through files, reading them in
for (i in 1:length(filenames))
{
data <- read.csv(filenames[i], header = TRUE,sep=",",na.strings="",check.names=FALSE)
names <- colnames(data)
basename = substr(basename(filenames[i]), 1, nchar(basename(filenames[i])) - 4)
fwd = paste(wd,basename,sep="/")
#Create a folder for each csv
dir.create(fwd)
setwd(fwd)
concept = concepts[which(concepts$id==basename),]
#If we have an ID and a year to widen it by, provide wide
if("id" %in% names & "year" %in% names)  {
wdata <- reshape(data,idvar="id",timevar="year",direction="wide")
write.csv(wdata,paste(basename,"-wide",".csv",sep=""),row.names=FALSE,na="")
}
#Copy the original CSV
file.copy(filenames[i],paste(basename,".csv",sep=""))
#Reference folder
rwd = paste(fwd,"reference",sep="/")
dir.create(rwd)
setwd(rwd)
#Provide meta-data from concepts.csv
#write.csv(concept,paste(basename,"-metadata-wide",".csv",sep=""),row.names=FALSE,na="")
write.table(t(concept),paste(basename,"-metadata",".csv",sep=""),col.names=FALSE,na="",sep=",")
if(basename %in% names(refMap)){
refNames = strsplit(refMap[[basename]],",")
for(j in 1:length(refNames)){
refBaseName = refNames[[j]]
refName = paste(refPath,refBaseName,".csv",sep="")
#Copy the reference files
file.copy(refName,paste(refBaseName,".csv",sep=""))
}
}
setwd(wd)
}
#Zip em up
filenames <- list.files(wd, pattern="/*", full.names=FALSE)
for(i in 1:length(filenames)){
files <- dir(filenames[i],full.names=TRUE)
zip(zipfile = filenames[i],files=files)
}
